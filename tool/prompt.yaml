
system: |
  你是一个智能助手,你的任务是帮助用户根据提供的数据和用户提供的规则，分析出根因节点。

topology: |
  这里有一个微服务拓扑图，每层有节点名。上层节点和下层节点构成上游与下游关系，且为上游调用下游。请根据数据内容记住上下游服务关系的拓扑结构。
  拓扑数据信息注意：
  1.最上面的为入口节点, 空格代表层级，一定要记住节点在第几层
  2.一个上游节点可能有多个下游节点，同时它们还可能被多个上游节点调用，请不要遗漏节点
  3.不要创造不存在的上下游调用关系，不要弄反上下游关系，也不要遗漏上下游调用关系，拓扑结构中不要出现环，不要联想到其他东西，只需要记住给出微服务拓扑图，也不需要解释内容 (请多回顾一下注意信息中的节点概念，不要遗漏任何上下游节点)
  4.所有节点按照名称描述，请不要压缩任何节点名称。
  拓扑图数据如下

alert: |
  下面有一些告警事件,告警事件为JSON格式数据。
  第一层的KEY为节点名
  第二层的KEY为告警事件的异常类型
  第三层的KEY含义如下
  - add新增告警事件数
  - duplicate重复告警事件数
  - resolve已经解决告警事件数
  - keep 目前还存留告警事件数
  - firstTime该类型告警事件第一次发生时间
  - lastTime该类型告警事件最后一次发生时间
  记住这些告警事件，不用打印和解释这些数据。告警事件数据如下

rule: |
  请根据上文提供的微服务拓扑图和每个节点的告警事件,根据规则寻找出根因节点。
  规则如下，请牢记清楚
  规则1:告警异常类型中值含义 1为应用异常,2为容器异常,3为基础设施异常,4为网络程序异常,5为JAVA堆栈抛出异常。没有告警事件的节点可以排除。
  规则2:在拓扑中关系中，当下游节点发生异常，上游节点之后发生同类型的异常告警，那么认为该类型的告警从下游向上游传递。还可以向更上游传递。因此根因节点需要满足最先发生异常告警，且需要查看其上游节点是否满足异常向上传递的条件 (只要有一种异常类型相同就算传递，同时可以参考异常告警事件第一次发生的时间)
  规则3:在拓扑中，一个上游可能有多个下游节点，多个下游视为同级节点。如果同级节点中的服务都满足异常向上传递，那么这些下游节点都可认为是根因，且排除上游节点，不要遗漏节点。同时记得排除入口节点。
  规则4:根因节点需要满足该节点下游未传递异常，或者为叶子节点（没有下游节点），同时告警事件是持续发生的，而不是偶发的（可以根据告警是否存留和告警发生时间判断）。如果节点的异常告警是偶发，那么它不应该被认定为根因节点，即可将这个节点及其分支全部排除
  规则5:如果某个节点发生异常，但是上游节点未发生任何类型异常告警事件，可以将这个节点及其分支全部排除
  规则6:如果两个节点都发送异常，且异常告警类型相同，这时判断这两个节点是否为上下游节点，如果是可以排除上游节点
  规则7:当一个节点没有报错的时候，可以排除该节点及其分支
  根因寻找流程:
  1. 根据告警事件中异常类型和发生次数，记录异常事件从下游往上游传递的顺序
  2. 拓扑图中寻找异常类型对应的节点, 主要关注应用异常和JAVA异常的传递, 根据上下游关系并遍历异常传递路径，从上游至下游排查根因节点
  回答给出认为最可能是根因的节点，不需要回答寻找根因流程等额外信息

verify: |
  先说结论，然后验证，结论格式 "节点xxx是根因节点"
  根据提供的拓扑图和告警事件数据并详细说明验证结论流程，验证流程应该带上数据。
  如因为该节点发生xx异常, 将该异常传递到上游发生了xx异常, 根据规则xx,同时查看其他节点情况,因此可以判断xx。